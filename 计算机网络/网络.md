# 1http

## 1.http 的特点

1.基于请求应答模式，一发一送，有来有回。

2.无状态，h不保存通信过程中的上下文。每次http请求都是独立不相关的。

3.可靠传输，基于Tcp/ip.



## 1.5状态码

1xx  信息型状态码

101 SwitchIng Protocols 当http协议转换为webScoket时，如果服务器同意转换，就会发送101

2xx  成功状态码

200 响应成功 数据放在响应体中

204 成功但是无数据

206 表示部分数据。用于http的分块下载。会带上Content-Range字段。



3xx  重定向状态码

301 代表永久重定向，表示资源分配了新的URL.

302 代表临时重定向，表示资源临时被分配了新的 URL。

当网站从http升级成https时，以前的站点都不用了，应当返回301. 这个时候浏览器默认会做缓存优化，在第二次访问的时候自动访问重定向的那个地址。

如果只是暂时不可用，那么直接返回`302`即可，和`301`不同的是，浏览器并不会做缓存优化。



304 协商缓存命中。



4xx  请求报文错误状态码

400 Bad Request 

403  服务器禁止访问

404 Not Found

405 请求的方法不被允许

406 资源无法满足客户端的条件

408 服务器等待太长时间

409 多个请求发生冲突

413 请求的数据太大



5xx  服务端错误状态码

500  服务器错误

501 客户端请求的功能还不支持

**502 Bad Gateway**: 网关错误

503：服务器超载



## 1.6 get 和 post 的区别

1. get会被浏览器缓存，post不会。
2. get使用url传参，不能使用敏感信息，而且传递参数有限。而post是在请求体中传参。较为适合传输敏感信息。
3. 从tcp的角度，get会一次性把请求报文发送出去，而post分成两个数据包。先发送headr,再发送body.



## 2.http的缺点

 1.无状态：在长连接场景中需要保存上下文，这个时候无状态就是http的缺点。

 2.队头阻塞问题：http长连接时共用一个tcp连接。服务端同时只能处理一个请求，在一个请求消耗过长时间的情况下，请求队列的其他请求就会被阻塞过久。这就是队列阻塞。

3.使用明文传输。把http报文信息暴露给了外界。

## 3如何解决对头阻塞问题：

1.并发连接，浏览器允许对同一个域名发起多个长连接，这就相当于增加了请求队列。

 2.域名分片。将一个域名的子域名都指向同一台主机。

## 4URI和UrL的区别

URI 在于I(Identifier)是统一资源标示符，可以唯一标识一个资源。

URL在于Locater，一般来说（URL）统一资源定位符，可以提供找到该资源的路径，比如http://www.zhihu.com/question/21950864，但URL又是URI，因为它可以标识一个资源，所以URL又是URI的子集。



## 5http 报文格式：

请求行|响应行 + 头部（通用头部，请求球部，响应头部）+实体

### Accept字段： 

 1.Accept:表示接受端想接收的特定类型的数据 

   Content-type:表示发送端发送数据的类型

 2.Accept-Ecoding:表示接收方接收什么样的压缩方式

   Content-Ecoding:表示发送方采用什么压缩方式

3 Accept-Language: 什么语言

  Content-Language

4 Accept-charset: 字符集

   Content-type

  

### 报文长度相关字段：

1. Content-Length ：定长报文

2. Transfer-Ecoding:chunked : 基于长连接持续发送动态内容



### 针对传输大文件，http采用范围请求。 

服务端：

 Accept-Ranges:bytes  :服务器端支持范围请求 

 Content-Range: 0-9/100 服务端返回0-9，总资源大小为100

  Content-Type: multipart/byteranges; boundary=00000010101

 服务端返回的 boundary用于在报文的响应体中做不同请求范围的分隔符



 请求端：

  Range: bytes=0-9  客户端请求0-9范围数据 

  Range: bytes=0-9, 30-39  客户端请求0-9 30-39范围的数据



总之Accept-Ranges和Content-Range为服务端返回的字段。

Range为客户端请求的数据范围。



### http中的表单处理

content-type 取以下的值。

1. application/x-www-form-urlencoded 

​     会将表单数据进行 url编码 以&为分隔符分隔不同数据

​     // 转换过程: {a: 1, b: 2} -> a=1&b=2 -> 如下(最终形   式)"a%3D1%26b%3D2"

  2.multipart/form-data

   请求头的content会带boundary指定表单分割数据用到分割符。不会进行编码。

   上传图片或者文件一般都用这个字段，因为不需要URL编码。



## 6.cookie

cookie:

   cookie是浏览器的4k大小的文本文件。内部以键值对的形式存储。向同一域名发送http请求会携带相同的cookie,服务端拿到cookie进行解析就可以得到客户端的状态。服务的可以通过set-Cookie字段将设置信息写入到客户端的cookie中。

   cookie的属性有：

   1.与生命周期有关：Expires:过期时间 Max-Age时间间隔

   2.与作用域有关：domain和path.

   3.与安全有关：Secure：只能用https传输 

   httpOnly：只能通过http协议传输，js不能访问





## 7.http代理

http请求的中间人，客户端发起请求到代理，代理再发送请求到目标网站主机。实现中转。代理即是客户端也是服务端。

代理可以实现负债均衡，通过代理服务器的算法来指定要发送到网站的哪一台服务器下。





## 8.跨域

由于浏览器的同源策略，(`scheme(协议)`、`host(主机)`和`port(端口)`都相同则为`同源`)非同源站点有这样一些限制:

- 不能读取和修改对方的 DOM
- 不读访问对方的 Cookie、IndexDB 和 LocalStorage
- 限制 XMLHttpRequest 请求。(后面的话题着重围绕这个)



### 跨域的解决方案

1. CORS  (Cross-Origin-Resource-Sharing)跨域资源共享



#### 1对于简单请求（Get,Post,Head）

1. 浏览器发送跨域http请求时，会有一个额外的头部 Origin.包含了发送该请求源站的url.

2. 如果服务器决定响应请求，就会加入 Access-Control-Allow-Origin:<请求源站的url> .
3. 浏览器收到响应后看到有该头部字段就不会丢弃响应。     



#### 2对于复杂请求

 1.浏览器先发送预检请求。

 2.服务的返回相应报文后，有以下字段

Access-Control-Allow-Origin: 表示可以允许请求的源，可以填具体的源名，也可以填`*`表示允许任意源请求。

Access-Control-Allow-Methods: 表示允许的请求方法列表。

Access-Control-Allow-Credentials: 简单请求中已经介绍。

Access-Control-Allow-Headers: 表示允许发送的请求头字段

Access-Control-Max-Age: 预检请求的有效期，在此期间，不用发出另外一条预检请求。

 3.客户端根据预检响应报文判断复杂请求可发送后，然后才发送真正的http请求。



##  9什么是CSRF(Cross-site request forgery) 

跨域请求伪造：是攻击者第三方网站通过欺骗用户的浏览器去访问一个用户的浏览器曾经认证过的网站并运行一些操作。

CSRF 攻击就是攻击者是利用用户的登录态发起恶意请求.



## 1.常见的CRSF攻击



1.get 

 危险网站B在img标签中插入要访问用户认证过的网站A。

2.post

   危险网站B利用一个自动提交的表单，表单的提交地址为用户认证过的网站A.

3.链接型CRSF.

  将链接的的href设置用户认证过的网站A.





## 2CRSF特点 

1. 攻击发起方一般为第三方网站。

   2.冒用用户信息提交操作。



## 3如何防御



1.利用token.





## 10.XSS攻击

### 1简介： 

xss跨站脚本攻击，是一种脚本注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本获取用户的cookie，sessionId,进而危害数据安全。

xss的本质是恶意代码未经过滤，和正常代码一起，浏览器无法分辨哪些是恶意代码导致恶意代码被执行。由于这些代码在用户终端执行，所以能获取到用户信息。恶意代码利用获取到的用户信息可以冒充用户完成相应的操作。



### 2.xss常见的注入方法。



在 HTML 中内嵌的文本中，恶意内容以 script 标签形成注入。

在内联的 JavaScript 中，拼接的数据突破了原本的限制（字符串，变量，方法名等）。

在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签。

在标签的 href、src 等属性中，包含 `javascript:` 等可执行代码。

在 onload、onerror、onclick 等事件中，注入不受控制代码。

在 style 属性和标签中，包含类似 `background-image:url("javascript:...");` 的代码（新版本浏览器已经可以防范）。

在 style 属性和标签中，包含类似 `expression(...)` 的 CSS 表达式代码（新版本浏览器已经可以防范）。





### 3xss的分类



#### 1.存储型xss攻击

​    攻击者通过将恶意代码插入网站主机的数据库中，当用户访问网站时，网站从数据库查询到恶意代码拼接成html返回给浏览器。浏览器解析执行后恶意代码能获取用户的信息。冒充用户发送信息攻击网站。 这种攻击常见于用户有保存数据到网站的数据库，库如商品评论等。



#### 2反射型xss攻击

 攻击者构造出特殊的url，内含恶意代码。用户打开url，网站服务端将恶意代码从url中取出，拼接到html返回给浏览器。浏览器接收到后解析执行同时恶意代码也被执行。



#### 3Dom型xss攻击

攻击者构造出特殊的 URL，其中包含恶意代码。用户打开url,用户浏览器接收到响应后解析执行，前端js取出url中的恶意代码并执行。恶意代码冒充用户访问网站。



### 4xss攻击的预防

#### 1.预防用户输入恶意代码。

输入过滤



#### 2.防范浏览器执行恶意代码。

##### 1.防止html出现注入

 1.改为纯前端渲染，把代码和数据分开

 2.对html做充分的转义。

##### 2防止javaScript执行时，执行恶意代码

 在使用 .innerHTML .outerHTML document.write()要小时不要将恶意代码插入其中。





## 11 http1.1

 http1.1是当前助理的http版本。有以下特点

1.  **默认持久连接**，tcp连接默认不断开,可以被多个请求复用,不用声明 Connection :keep-alive. **长连接时长可以再keep-alive 字段中设置**。
2. 引入管道机制，在同一个tcp连接中可以立即发送tcp请求且不用等待上一次请求的响应。
3. 新增 tag,if-None-Match等头部字段来控制http缓存失效。
4. 支持断点续传，在请求头的 Range 字段中请求断点范围。 （响应投 Accept-Range:bytes Range-Content:）



## 12 http 2.0

1. 头部压缩。http的头部字段会使用hpack算法进行压缩。
2. 二进制分帧。头信息和数据体都是二进制，并且统称为"帧"：头信息帧和数据帧。
3. 多路复用。复用tcp连接，在一个连接中，客户端和服务端可以同时发送多个请求和响应，且不用按顺序。
4. 服务端推送。服务端可以主动发送报文到客户端。
5. 请求优先级。可以设置数据帧的优先级，让服务端优先处理重要资源。



## 13https

HTTPS = HTTP + SSL/TLS  准确地说，**TLS1.0 = SSL3.1**。

现在主流的版本是 TLS/1.2.  

1. HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议
2. HTTPS标准端口443，HTTP标准端口80。





###   1https 的加密过程

1. 客户端向服务端发起第一次握手，告知服务端客户端所支持的SSL版本，加密算法和密钥长度等信息。
2. 服务器端将自己的公钥发送刚给数字证书认证机构，数字证书认证机构利用自己的私钥对服务器的公钥进行加密，并给服务器颁发证书。
3. 服务器端将证书发送给客户端
4. 客户端利用数字机构的公钥（在很多浏览器开发时，会内置常用数字证书认证机构的公钥），向数字证书认证机构验证公钥证书上的数字签名，确认服务器公开密钥的真实性。
5. 客户端用服务器端的公开密钥加密自己的对称密钥发送给服务端
6. 服务端用密钥解开信息获得客户端的对称密钥。
7. 通信双方可以通过对称密钥来加密信息。

