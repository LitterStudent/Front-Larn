# 0网络分层



<img src="C:\Users\15439\AppData\Roaming\Typora\typora-user-images\image-20211013123124957.png" alt="image-20211013123124957" style="zoom:67%;" />

1. 应用层：为应用程序提供交互服务。如http，DNS.协议等
2. 运输层：为两台主机间的应用进程间提供信息传输。如tcp和udp.
3. 网络层：选择合适的**路由和交换节点**，确保数据及时传送。如ip协议。
4. 数据链路层：将网络层传下来的**IP数据包组装成帧**，并再**相邻节点的链路上传送帧**。
5. 物理层：实现相邻节点间**比特流的透明传输**，尽可能**屏蔽传输介质和通信手段的差异。**



## 1tcp/ip协议簇：指在使用ip协议时会用到的协议群的统称。

## <img src="C:\Users\15439\AppData\Roaming\Typora\typora-user-images\image-20211013123433768.png" alt="image-20211013123433768" style="zoom: 67%;" />

## 2.输入url后浏览器发生了什么：

1. ​         浏览器查找dns缓存，查看是否有相应的ip地址，如果没有就从操作系统的hosts文件查找，还是没有就向本地dns服务器发送递归查询。
2. 本地dns服务器开始向根域名服务器，顶级域名服务器和权限域名服务器依次迭代查询。如果查询到想要的ip地址就停下来转发给主机。
3. 主机获取到ip地址后，操作系统先将其存入hosts文件，在传送给浏览器，浏览器存入浏览器内的dns缓存后开始输入ip地址。
4. 浏览器开始tcp的连接。实现三次握手。 syn x  ack x+1 syn q  ack q+1
5. 浏览器开始和服务器通讯，发起http请求。浏览器根据请求地址查看是否有该请求结果的缓存标识和缓存结果。如果有根据catche-control字段查看是否过期，如果没有就直接使用。如果过期了就进行协商缓存。
6. 协商缓存向服务器发送报文 包含 if-None-Match 为 缓存标识 Etag ,如果服务器返回304则协商缓存命中，继续使用协商缓存。跟新浏览器缓存时间。如果返回200则直接跟新浏览器缓存内容。
7. 浏览器获取数据，解析文件，渲染生成页面。
8. http通讯结束后tcp断开连接。四次挥手。

# 1http

## 1.http 的特点

1.基于请求应答模式，一发一送，有来有回。

2.无状态，不保存通信过程中的上下文。每次http请求都是独立不相关的。

3.可靠传输，基于Tcp/ip.

4.灵活可扩展，HTTP允许传输任意类型的数据。传输的类型由Content-Type加以标记。



## 1.5状态码

1xx  信息型状态码

101 SwitchIng Protocols 指示服务器也正在切换的协议。 当http协议转换为webScoket时，如果服务器同意转换，就会发送101

2xx  成功状态码

200 响应成功 数据放在响应体中

204 成功但是无数据

206 表示部分数据。用于http的分块下载。会带上Content-Range字段。



3xx  重定向状态码

301 代表永久重定向，表示资源分配了新的URL.

302 代表临时重定向，表示资源临时被分配了新的 URL。

当网站从http升级成https时，以前的站点都不用了，应当返回301. 这个时候浏览器默认会做缓存优化，在第二次访问的时候自动访问重定向的那个地址。

如果只是暂时不可用，那么直接返回`302`即可，和`301`不同的是，浏览器并不会做缓存优化。



304 协商缓存命中。



4xx  请求报文错误状态码

400 Bad Request 

403 Forbidden 服务器禁止访问

404 Not Found

405 请求的方法不被允许

406 资源无法满足客户端的条件

408 服务器等待太长时间

409 多个请求发生冲突

413 请求的数据太大



5xx  服务端错误状态码

500  服务器错误

501 服务器不支持客户端请求的功能

**502 Bad Gateway**: 网关错误

503：服务器超载



## 1.6 get 和 post 的区别

1. get会被浏览器缓存，post不会。
2. get使用url传参，不能使用敏感信息，而且传递参数有限。而post是在请求体中传参。较为适合传输敏感信息。
3. 从编码的角度，get请求只支持URL编码，只接受ASCII编码。而POST接受更多的编码请求。



## 1.7Options 方法的作用

用于查看服务器某个资源支持哪些请求方法。

也可以通过将资源名设置为 * 向服务器OPTIONS发送请求,来检测服务器是否正常。



## 2.http的缺点

 1.无状态：在**长连接场**景中需要保存上下文，这个时候无状态就是http的缺点。

 2.队头阻塞问题：http长连接时共用一个tcp连接。服务端同时只能处理一个请求，在一个请求消耗过长时间的情况下，**请求队列**的其他请求就会被阻塞过久。这就是队列阻塞。

3.使用明文传输。把http报文信息暴露给了外界。

## 3如何解决对头阻塞问题：

1.并发连接，浏览器允许对同一个域名发起多个长连接，这就相当于增加了请求队列。

 2.域名分片。将一个域名的子域名都指向同一台主机。

## 4URI和UrL的区别

URI 在于I(Identifier)是统一资源标示符，可以唯一标识一个资源。

URL在于Locater，一般来说（URL）统一资源定位符，可以提供找到该资源的路径，比如http://www.zhihu.com/question/21950864，但URL又是URI，因为它可以标识一个资源，所以URL又是URI的子集。



## 5http 报文格式：

请求行|响应行 + 头部（通用头部，请求球部，响应头部）+实体

### Accept字段： 

 1.Accept:表示接受端想接收的特定类型的数据 

   Content-type:表示发送端发送数据的类型

text： text/html, text/plain, text/css 等

image: image/gif, image/jpeg, image/png 等

audio/video: audio/mpeg, video/mp4 等

application: application/json, application/javascript, application/pdf, application/octet-stream



 2.Accept-Ecoding:表示接收方接收什么样的编码压缩方式

   Content-Ecoding:表示发送方采用什么编码压缩方式

- gzip: 当今最流行的压缩格式
- deflate: 另外一种著名的压缩格式
- br: 一种专门为 HTTP 发明的压缩算法

3 Accept-Language: 什么语言

  Content-Language

4 Accept-charset: 字符集

   Content-type

  

### 报文长度相关字段：

1. **Content-Length** ：定长报文

2. **Transfer-Ecoding:chunked** : 基于**长连接持**续发送动态内容。优先级高于Content-Length

   



### 针对传输大文件，http采用范围请求。 

服务端：

 Accept-Ranges:bytes  :服务器端支持范围请求 

 Content-Range: 0-9/100 服务端返回0-9，总资源大小为100

  Content-Type: multipart/byteranges; boundary=00000010101

 服务端返回的 boundary用于在报文的响应体中做不同请求范围的分隔符



 请求端：

  Range: bytes=0-9  客户端请求0-9范围数据 

  Range: bytes=0-9, 30-39  客户端请求0-9 30-39范围的数据



总之Accept-Ranges和Content-Range为服务端返回的字段。

Range为客户端请求的数据范围。



### http中的表单处理

content-type 取以下的值。

1. application/x-www-form-urlencoded 

​     会将表单数据进行 url编码 以&为分隔符分隔不同数据

​     // 转换过程: {a: 1, b: 2} -> a=1&b=2 -> 如下(最终形   式)"a%3D1%26b%3D2"

  2.multipart/form-data

   请求头的content会带boundary指定表单分割数据用到分割符。不会进行编码。

   上传图片或者文件一般都用这个字段，因为不需要URL编码。









## 6.cookie

cookie:

   cookie是浏览器的4k大小的文本文件。内部以键值对的形式存储。向同一域名发送http请求会携带相同的cookie,服务端拿到cookie进行解析就可以得到客户端的状态。服务的可以通过set-Cookie字段将设置信息写入到客户端的cookie中。

   cookie的属性有：

   1.与生命周期有关：**Expires**:过期时间   **Max-Age**时间间隔

   2.与作用域有关：domain和path.

   3.与安全有关：Secure：只能用https传输 

   httpOnly：只能通过http协议传输，js不能访问

   4.对于 CSRF 攻击的预防，也有`SameSite`属性

`SameSite`可以设置为三个值，`Strict`、`Lax`和`None`。

**a.** 在`Strict`模式下，浏览器完全禁止第三方请求携带Cookie。比如请求`sanyuan.com`网站只能在`sanyuan.com`域名当中请求才能携带 Cookie，在其他网站请求都不能。

**b.** 在`Lax`模式，就宽松一点了，但是只能在 `get 方法提交表单`况或者`a 标签发送 get 请求`的情况下可以携带 Cookie，其他情况均不能。

**c.** 在`None`模式下，也就是默认模式，请求会自动携带上 Cookie。





## 7.http代理

http请求的中间人，客户端发起请求到代理，代理再发送请求到目标网站主机。实现中转。代理即是客户端也是服务端。

代理可以实现负债均衡，通过代理服务器的算法来指定要发送到网站的哪一台服务器下。





## 8.跨域

由于浏览器的同源策略，(`scheme(协议)`、`host(主机)`和`port(端口)`都相同则为`同源`)非同源站点有这样一些限制:

- 不能读取和修改对方的 DOM
- 不读访问对方的 Cookie、IndexDB 和 LocalStorage
- 限制 XMLHttpRequest 请求。(后面的话题着重围绕这个)



### 跨域的解决方案

1. CORS  (Cross-Origin-Resource-Sharing)跨域资源共享



#### 1对于简单请求（Get,Post,Head）

1. 浏览器发送跨域http请求时，会有一个额外的头部 Origin.包含了发送该请求源站的url.

2. 如果服务器决定响应请求，就会加入 Access-Control-Allow-Origin:<请求源站的url> .
3. 浏览器收到响应后看到有该头部字段就不会丢弃响应。     



#### 2对于复杂请求

 1.浏览器先发送预检请求。

 2.服务的返回相应报文后，有以下字段

Access-Control-Allow-Origin: 表示可以允许请求的源，可以填具体的源名，也可以填`*`表示允许任意源请求。

Access-Control-Allow-Methods: 表示允许的请求方法列表。

Access-Control-Allow-Credentials: 简单请求中已经介绍。

Access-Control-Allow-Headers: 表示允许发送的请求头字段

Access-Control-Max-Age: 预检请求的有效期，在此期间，不用发出另外一条预检请求。

 3.客户端根据预检响应报文判断复杂请求可发送后，然后才发送真正的http请求。



##  9什么是CSRF(Cross-site request forgery) 

跨域请求伪造：是攻击者第三方网站通过欺骗用户的浏览器去访问一个用户的浏览器曾经认证过的网站并运行一些操作。

CSRF 攻击就是攻击者是利用用户的登录态发起恶意请求.



## 1.常见的CRSF攻击



1.get 

 危险网站B在img标签中插入要访问用户认证过的网站A。

2.post

   危险网站B利用一个自动提交的表单，表单的提交地址为用户认证过的网站A.

3.链接型CRSF.

  将链接的的href设置用户认证过的网站A.





## 2CRSF特点 

1. 攻击发起方一般为第三方网站。
2. 冒用用户信息提交操作。



## 3如何防御

1.利用token.

**1. 将CSRF Token输出到页面中**

首先，用户打开页面的时候，服务器需要给这个用户生成一个Token，该Token通过加密算法对数据进行加密，一般Token都包括随机字符串和时间戳的组合，显然在提交时Token不能再放在Cookie中了，否则又会被攻击者冒用。因此，为了安全起见Token最好还是存在服务器的Session中，之后在每次页面加载时，使用JS遍历整个DOM树，对于DOM中所有的a和form标签后加入Token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的HTML代码，这种方法就没有作用，还需要程序员在编码时手动添加Token。

**2. 页面提交的请求携带这个Token**

对于GET请求，Token将附在请求地址之后，这样URL 就变成 http://url/?csrftoken=tokenvalue。 而对于 POST 请求来说，要在 form 的最后加上：

```html
  <input type=”hidden” name=”csrftoken” value=”tokenvalue”/>
```

这样，就把Token以参数的形式加入请求了。

**3. 服务器验证Token是否正确**

当用户从客户端得到了Token，再次提交给服务器的时候，服务器需要判断Token的有效性，验证过程是先解密Token，对比加密字符串以及时间戳，如果加密字符串一致且时间未过期，那么这个Token就是有效的。



## 10.XSS攻击

### 1简介： 

xss跨站脚本攻击，是一种脚本注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本获取用户的cookie，sessionId,进而危害数据安全。

xss的本质是恶意代码未经过滤，和正常代码一起，浏览器无法分辨哪些是恶意代码导致恶意代码被执行。由于这些代码在用户终端执行，所以能获取到用户信息。恶意代码利用获取到的用户信息可以冒充用户完成相应的操作。



### 2.xss常见的注入方法。



在 HTML 中内嵌的文本中，恶意内容以 script 标签形成注入。

在内联的 JavaScript 中，拼接的数据突破了原本的限制（字符串，变量，方法名等）。

在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签。

在标签的 href、src 等属性中，包含 `javascript:` 等可执行代码。

在 onload、onerror、onclick 等事件中，注入不受控制代码。

在 style 属性和标签中，包含类似 `background-image:url("javascript:...");` 的代码（新版本浏览器已经可以防范）。

在 style 属性和标签中，包含类似 `expression(...)` 的 CSS 表达式代码（新版本浏览器已经可以防范）。





### 3xss的分类



#### 1.存储型xss攻击

​    攻击者通过将恶意代码插入网站主机的数据库中，当用户访问网站时，网站从数据库查询到恶意代码拼接成html返回给浏览器。浏览器解析执行后恶意代码能获取用户的信息。冒充用户发送信息攻击网站。 这种攻击常见于用户有保存数据到网站的数据库，库如商品评论等。



#### 2反射型xss攻击

 攻击者构造出特殊的url，内含恶意代码。用户打开url，网站服务端将恶意代码从url中取出，拼接到html返回给浏览器。浏览器接收到后解析执行同时恶意代码也被执行。



#### 3Dom型xss攻击

攻击者构造出特殊的 URL，其中包含恶意代码。用户打开url,用户浏览器接收到响应后解析执行，前端js取出url中的恶意代码并执行。恶意代码冒充用户访问网站。



### 4xss攻击的预防

#### 1.预防用户输入恶意代码。

输入过滤



#### 2.防范浏览器执行恶意代码。

##### 1.防止html出现注入

 1.改为纯前端渲染，把代码和数据分开

 2.对html做充分的转义。

##### 2防止javaScript执行时，执行恶意代码

 在使用 .innerHTML .outerHTML document.write()要小心不要将恶意代码插入其中。



### 5xss 和 CRSF

1.XSS 全称“跨站脚本攻击”，是注入攻击的一种。其特点是不对服务器端造成任何伤害，而是通过一些正常的站内交互途径，例如发布评论，提交含有 JavaScript 的内容文本。这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这些脚本。

2.CSRF 的全称是“跨站请求伪造”，而 XSS 的全称是“跨站脚本”。看起来有点相似，它们都是属于跨站攻击——不攻击服务器端而攻击正常访问网站的用户，但前面说了，它们的攻击类型是不同维度上的分 类。CSRF 顾名思义，是伪造请求，冒充用户在站内的正常操作。我们知道，绝大多数网站是通过 cookie 等方式辨识用户身份（包括使用服务器端 Session 的网站，因为 Session ID 也是大多保存在 cookie 里面的），再予以授权的。所以要伪造用户的正常操作，最好的方法是通过 XSS 或链接欺骗等途径，让用户在本机（即拥有身份 cookie 的浏览器端）发起用户所不知道的请求。

3.XSS 是实现 CSRF 的诸多途径中的一条，但绝对不是唯一的一条。一般习惯上把通过 XSS 来实现的 CSRF 称为 XSRF。



## 11 http1.1，http1.0

http1.0

1. 默认不开启持久连接，每次发起请求都需要重新进行tcp连接的建立。
2. 使用 Expires和 if-modify-Since和Last-modify等字段来控制浏览器缓存。
3. htpp1.0不支持范围断点续传功能。当浏览器想请求部分资源时只能一次性请求整个资源。

 http1.1是当前最常用的http版本。有以下特点

1.  **默认持久连接**，tcp连接默认不断开,可以被多个请求复用,不用声明 Connection :keep-alive. **长连接时长可以再keep-alive 字段中设置**。
2. 引入管道机制，在同一个tcp连接中可以连续发送多个http请求。
3. 新增 Etag,if-None-Match等头部字段来控制http缓存失效。
4. 支持断点续传，在请求头的 Range 字段中请求断点范围。 （响应投 Accept-Range:bytes Range-Content:）

http1.0 定义了三种请求方法：GET,POST，HEAD.

http1.1新增了五种请求方法：options,put,delete,trace,connect

## 11.1http缓存

<img src="C:\Users\15439\AppData\Roaming\Typora\typora-user-images\image-20211019101822022.png" alt="image-20211019101822022" style="zoom:67%;" />

1. 浏览器先根据这个资源的http头信息来判断是否命中强缓存。主要是通过Cache-Control和Expires两个字段来判断，Cache-Cobtrol的优先级比较高，如果命中则直接加在缓存中的资源，并不会将请求发送到服务器。
2. 如果强缓存未命中，浏览器就会将资源加载请求发送到服务器。服务器来判断浏览器的本地缓存是否失效。若未失效，服务器不会返回资源信息。浏览器可以继续从缓存从加载资源
3. 如果未命中协商缓存，则服务器会将完整的资源返回浏览器。浏览器加载新资源并且更新缓存。



强制缓存是利用http响应头的 Expires 和 Cache-Control 两个字段来控制的。表示资源的缓存时间。

Expires是一个时间，表示该时间之前浏览器缓存都有效。比如Expires:Thu,31 Dec 2037 23:59:59 GMT。缓存在2037年12月31日23点59分59秒之前都是有效的，即命中缓存。但是需要浏览器的时间与服务器的时间是同步的才能没有误差。

所以有了Cache-Control,相对的时间。

Cache-Control:3600，代表着资源的有效期是3600秒。



协商缓存是通过 Etag/if-none-match 或 Last-modify/if-modify-Since 字段来实现的。

当浏览器第一次发起请求的时候，服务器返回的报文会包含 Last-modify(表示资源最后修改时间)或者E-Tag(资源的唯一标识)。

当浏览器想判断缓存是否失效时进行协商缓存，发送的请求报文头部字段会包含 if-modify-since值为上次的 Las-modify.或者时发送if-none-match值为上次的Etag.给服务器判断浏览器的缓存是否过期。如果过期就会返回200并携带最新的资源，浏览器收到后更新缓存。如果没过期就返回304.浏览器收到后浏览器可以继续使用原来的缓存。



## 12 http 2.0

1. 头部压缩。http的头部字段会使用hpack算法进行压缩。
2. 二进制分帧。头信息和数据体都是二进制，并且统称为"帧"：头信息帧和数据帧。
3. 多路复用。复用tcp连接，在一个连接中，客户端和服务端可以同时发送多个请求和响应，且不用按顺序。
4. 服务端推送。服务端可以主动发送报文到客户端。
5. 请求优先级。可以设置数据帧的优先级，让服务端优先处理重要资源。



## 13https

https就是在http的下面增加了一层ssl协议。

HTTPS = HTTP + SSL/TLS  准确地说，**TLS1.0 = SSL3.1**。

现在主流的版本是 TLS/1.2.  

1. HTTPS 协议是由 SSL+HTTP 协议构建的可进行**加密传输、身份认证**的网络协议
2. HTTPS标准端口443，HTTP标准端口80。





###   1https 的加密过程

（客户端先发一个Client Hello的包，然后服务端响应一个Server Hello，接着再给客户端发送它的证书，然后双方经过密钥交换，最后使用交换的密钥加解密数据。）



1. 客户端向服务端发起https请求，连接443端口。（告知服务端客户端所支持的SSL版本，加密算法和密钥长度等信息）
2. 服务器端将自己的公钥发送给数字证书认证机构，数字认证机构根据公钥生成证书，并给服务器颁发证书。证书包含证书内容，签名算法和数字签名三部分内容。数字认证机构通过签名算法对证书内容进行hash获得hash值，然后再用自己的私钥对hash值进行加密得到数字签名。
3. 服务器端将证书发送给客户端。
4. **客户端利用数字机构的公钥，对私钥加密的数字签名进行解密得到真正的签名。**
5. **客户端在通过签名生成规则生成签名，看看于解密得到的签名是否匹配。如果匹配则认证通过。获取服务器公钥成功**。
6. 客户端用服务器端的公钥加密自己的对称密钥发送给服务端
7. 服务端用密钥解开信息获得客户端的对称密钥。
8. 通信双方可以通过对称密钥来加密信息。



### 2.什么是数字签名证书？

[好文](https://www.nowcoder.com/discuss/751740?channel=-1&source_id=profile_follow_post_nctrack)

服务端可以向证书颁发机构CA申请证书，以避免**中间人攻**击（防止证书被篡改）。证书包含三部分内容：tbsCertificate（to be signed certificate）待签名证书内容、证书签名[算法]()和CA给的签名（使用证书签名[算法]()对tbsCertificate进行哈希运算得到哈希值，CA会用它的私钥对此哈希值进行签名，并放在签名部分）。签名是为了验证身份。

![img](https://uploadfiles.nowcoder.com/files/20210921/8683776_1632204112010/https-certificate.png)

服务端把证书传输给浏览器，浏览器从证书里取公钥。证书可以证明该公钥对应该网站。

数字签名的制作过程：

1. CA使用证书签名[算法]()对证书内容（待签名证书内容）进行hash。 
2. 对hash后的值用CA自己的私钥加密，得到数字签名。 

浏览器验证过程：

1. 拿到证书，得到证书内容、证书签名[算法]()和数字签名。 
2. 用CA机构的公钥对数字签名解密（由于是浏览器信任的机构，所以浏览器会保存它的公钥）。 
3. 用证书里的签名[算法]()对证书内容进行hash。 
4. 比较解密后的数字签名和对证书内容hash后的哈希值，相等则表明证书可信。

### 3 SSL断开后如何重连。

1. 使用session_id的方式。每一次会话都会维护一个session_id.当前会话断开后，只要下一次重新连接，客户端能给出这个session_id，而且服务端有这个编号，就可以重启上次会话。重用之前的对称密钥加密信息。但是这种方法有一个缺点是，session ID 只能够存在一台服务器上，如果我们的请求通过负载平衡被转移到了其他的服务器上，那么就无法恢复对话。
2. 另一种方式是 session ticket 的方式，session ticket 是服务器在上一次对话中发送给客户的，这个 ticket 是加密的，只有服务器能够解密，里面包含了本次会话的信息，比如对话秘钥和加密方法等。这样不管我们的请求是否转移到其他的服务器上，当服务器将 ticket 解密以后，就能够获取上次对话的信息，就不用重新生成对话秘钥了。

## 14短轮循，长轮循，webScoket.

1.短轮循

 浏览器每隔一段时间就向服务器发送请求，服务器收到请求后不论服务器端是否有数据更新都直接响应。客户端通过不断的请求来模拟实时获取服务端的数据变化。通过这种方式来实现即时通讯。

缺点：不断请求会浪费资源。

2.长轮循。

浏览器向服务端发送一个请求后，服务端先将请求挂起，并判断数据是否发生变化。当发生变化时返回响应报文。如果一段时间内还没有发生变化，则直接返回报文。客户端在接受到响应后再发送请求。

缺点：连接挂起会浪费资源。

3.webScoket

h5的新协议。全双工通讯协议，允许服务端主动向客户端推送信息。通信双方相互平等，可以互相发送信息。



## 15 反向代理和正向代理

反向代理是代理服务器端，通过接受客户端的请求来分发到服务器端。此时代理服务器对外界表现的像一个服务器。



反向代理是服务端代理，代理服务端。客户端并不知道真正提供服务的的服务端。

正向代理是客户端代理，代理客户端。服务器端不知道发送请求的真正客户端。



反向代理实现负载均衡：用户的请求都发送到反向代理服务上，然后由反向代理服务器来转发请求到真实的服务器上，以此来实现集群的负载平衡。



# 2DNS

(Domain Name System)域名系统 （一个记录ip地址的超级分布式数据库）

## 1.域名结构

![image-20211012140721759](C:\Users\15439\AppData\Roaming\Typora\typora-user-images\image-20211012140721759.png)

常见的顶级域名有：cn（中国） us(美国)  com  net

![image-20211012141046828](C:\Users\15439\AppData\Roaming\Typora\typora-user-images\image-20211012141046828.png) 



## 2.DNS解析过程： 

1. 浏览器先检查dns缓存是否有该域名的ip地址，有则直接使用，没有的话会再检查操作系统的hosts文件，再没有的话才向本地域名服务器发起请求。
2. 主机向**本地域名服务器**发送请求，请求域名解析，进行递归查询。
3. 本地域名服务器查询自己的DNS缓存，查找成功则返回结果，否则依次向根域名服务器、顶级域名服务器、权限域名服务器依次迭代发起查询请求，直到本地域名服务器获得请求的域名所属的IP地址。
4. 本地域名服务器再将ip地址返回给主机，同时自己也会缓存起来。
5. 主机操作系统会将ip地址和域名缓存到hosts文件，并传给浏览器。浏览器再缓存到dns缓存。

![image-20211012150343154](C:\Users\15439\AppData\Roaming\Typora\typora-user-images\image-20211012150343154.png)

## 3DNS负载均衡

每次使用DNS解析后得到的ip地址不一定相同。这是因为dns会根据该域名下分配的ip地址的服务器主机的负载量等信息来动态地为主机分配合适的服务主机。



另一种说法：

- 当用户发起网站域名的 DNS 请求的时候，DNS 服务器返回这个域名所对应的服务器 IP 地址的集合
- 在每个回答中，会循环这些 IP 地址的顺序，用户一般会选择排在前面的地址发送请求。
- 以此将用户的请求均衡的分配到各个不同的服务器上，这样来实现负载均衡。

## 4DNS为什么采用UDP协议

DNS采用UDP协议主要是为了避免使用tcp协议导致的时延。

为了得到一个域名地址，主机往往需要向多台本地域名服务器发起请求，如果采用tcp协议，每次请求都会存在连接时的时延。这样会使得DNS服务变慢。



# 3TCP

## 1 TCP的特点

1. **Tcp是面向连接的运输层协议。**应用程序在使用tcp协议之前必须先进行tcp连接。传输完数据后必须释放tcp连接。
2. **Tcp提供可靠交付服务**。通过tcp传输的数据是无差错，不重复，不丢失，按序到达。
3. **Tcp提供全双工通信。**Tcp允许发送双方的应用进程同在任何时候都能发送数据。TCP两端都设有发送缓存和接受缓存。tcp的应用进程在把数据传给发送缓存后就可以干自己的事情去了。而Tcp会在合适的时候将发送缓存的内容发送出去。在接收时，将数据放到接收缓存。上层的应用进程在合适的时候读取接收缓存获取数据。
4. **面向字节流。**虽然tcp于应用进程的交互时通过数据块，但是tcp把数据块当成字节流，将数据块放入缓存区中，在合适的时候将缓存区的数据以字节流的形式发送出去或者传递给应用进程。

tcp连接的两端的端点叫做套接字 ，由ip和端口号组成。

套接字（socket） = (ip地址：端口号)



## 2 Tcp的表头

​                 表头只是 20个字节。

<img src="https://docimg10.docs.qq.com/image/1Y2iV29NS2oAjEqbDbe5YQ.png?w=896&h=269" alt="img" style="zoom:80%;" />        

源端口号，目表端口

序列号：报文数据部分的第一个字节的序号

确认号：期待收到对方报文的下一个数据字节的序号

头部长度：4位    确认ACK  同步SYN 紧急URG  推送PSH: 终止FIN 复位RST  

紧急URG：发送应用进程将URG置为1时就是告诉发送方的tcp有紧急数据要处理。于是发送方TCP就将紧急数据插入到本报文段数据的最前面。

推送PSH：发送方TCP置为1时会立即将报文发送出去，**不用等缓存区满了再推送**。

终止FIN：释放TCP连接

复位RST：不懂。



窗口：2字节，报文发送方的窗口大小。 窗口值告诉报文接收方设置发送窗口的大小。



检验和：校验

紧急指针：当URG置为1时，数据报中数据部分紧急数据的长度。



## 3.Tcp的可靠性如何保证：

1. 分块传输：数据被分割成最合适的数据块(UDP的数据报长度不变)

2. 等待确认：发送端发送报文后，通过定时器设置等待接受端发送确认请求，收不到就重发报文。

3. 确认回复：接受端接收报文后，会通过确认号字段发送确认回复

4. 数据校验

5. 乱序重排：接收端能将乱序的数据报重新排序后再发送给应用进程

6. 重复丢弃：接收端会丢弃重复的报文

7. 流量缓冲：两端有固定大小的缓冲区（滑动窗口），防止速度不匹配丢数据

   

## 4.TCP常见面试题

### 1.三次握手过程和为什么要进行三次握手？

 c端： SYN seq=x   -------->                           s端    连接请求报文

 c端     <----------  SYN ACK seq=y ack=x+1  s端	连接接受报文

 c端      ACK seq=x+1 ack=y+1      ----->        s端

- 客户端发送SYN，表明要向服务器建立连接。同时带上序列号ISN
- 服务器返回ACK（序号为客户端序列号+1）作为确认。同时发送SYN作为应答（SYN的序列号为服务端唯一的序号）
- 客户端发送ACK确认收到回复（序列号为服务端序列号+1）

原因：

防止A发送的请求连接报文在信道中延迟过久，到TCP连接中断才传递至B端。此时如过是两次握手的话，B端就会向A端发出确认报文并保持该TCP连接，但事实上A端已经关闭，所以不会回复B,造成B的资源浪费。

**确保双方，同时能发数据和收数据**。因为TCP是全双工的。

A发送第一个报文，确保了 A具有发送的能力。

B接收到报文，发送回复报文给A.确保了B具有发送和接受的能力。

A再发送报文给B.确保了A能接受到B的报文。



###  2.四次挥手过程和为什么要四次挥手？

FIN-Wait 1 A   FIN seq=u  ---->                                   B  ESTablshed

FIN-Wait 1 A    <------  ACK  ack=u+1 seq=v               B   CLOSED-WAIT

FIN-Wait 2 A     <------  可能发送剩余信息                   B  CLOSED-WAIT

FIN-Wait 2  A   <-------   ACK+FIN  ack=u+1 seq=w    B  LAST-ACK

TIME-Wait  A      ACK ack=w+1 seq=u+1      ------>    B  CLOSE

- 主动关闭的一方发送FIN，表示要单方面关闭数据的传输
- 服务端收到FIN后，发送一个ACK作为确认（序列号为收到的序列号+1）
- 等服务器数据传输完毕，也发送一个FIN标识，表示关闭这个方向的数据传输
- 客户端回复ACK以确认回复

原因：1因为tcp是全双工的，数据能才两个方向上同时传输。且tcp支持半关闭，即一端停止发送数据但是仍能接受数据。因此每个方向都要单独关闭，且收到关系通知后要确认。

2.因为 服务端在收到客户端的断开连接请求后，可能还存有要发送的数据没发送完，所以才先发送确认收到服务端FIN报文的确认报文后，再继续发送剩余数据。发送完数据之后才发送确认断开连接的FIn报文。



### 3第四次挥手客户端等待2MSL 2个最大报文生存时间 的意义？

为了确保服务端能收到客户端 的确认报文。确保此次连接的tcp报文都彻底消失不会再影响下一次tcp的连接。

第一个msl是为了保证服务端收到确认报文，如果第一个msl内服务端没有收到确认报文就会重发fin报文。然后客户端就会在1msl内收到报文。



## 5滑动窗口协议（流量控制）

1. TCP利用滑动窗口的机制实现流量控制。TCP的会话双方都会维护一个各自的发送窗口和接受窗口。接受窗口大小是取决于应用，系统，硬件等条件。发送窗口取决于对方发送的接受窗口。接受方发送的确认报文通过设置window字段来设置发送方的发送 窗口大小从而影响发送方的发送速率。当接受方设置窗口大小为0时，发送方就不能发送数据。	



## 6拥塞控制



![image-20211013112731729](C:\Users\15439\AppData\Roaming\Typora\typora-user-images\image-20211013112731729.png)

目的：拥塞控制是为了防止过多的数据注入到网络。拥塞控制的几种方法：慢开始，拥塞避免，快重传，快恢复。

1. 拥塞窗口cwnd设置为一个最大报文长度MSS的数值。而且在**每收到一个确认报文后就将拥塞窗口增加多一个MSS的值**。即**拥塞窗口cwnd翻倍**。为了防止拥塞窗口过大引起网络拥塞，设置慢开始门限ssthresh。**当拥塞窗口的值到达慢开始门限后ssthresh开始拥塞避免算法。**
2. 拥**塞避免时，每经过一个往返时间RTT，拥塞窗口的值就加1.线性缓慢增长**。
3. 无论是在慢开始阶段还是拥塞避免阶段，只要发送方判断出网络中出现拥塞就会将拥塞窗口设为1，慢开始门限设为发生拥塞时的拥塞窗口的一半，然后执行慢开始算法。这样做的目的为了网络中堆积的报文分组有时间被处理掉。
4. 当个别报文段在网络中丢失后，接受方收到乱序的报文段就会**开启快重传算法，连续发送三个ack报文给发送方**，告知发送方报文丢失。
5. 发送方只要收到三个ack报文就可以判断出发送的报文丢失。然后**将拥塞窗口的值cwnd降为慢开始门限的一半**。然后开始拥塞避免，拥塞窗口线性增长。



# 4UDP

8个字节。有4个字段各占2各字节。 源端口，目的端口。数据报长度。检验和。

## 1TCP和UDP的区别。

1. TCP是面向连接的，UDP是无连接，UDP发送数据前不需要建立连接。
2. TCP面向字节流，把数据看成无结构的字节流。UDP是面向报文的。应用层交付的报文不论长短，UDP都只添加一个首部然后交付给IP层。
3. UDP没有拥塞控制，当网络阻塞时会也不会采取相应措施。
4. tcp首部至少20各字节，udp只有8各字节



## 2为什么说UDP没有TCP可靠？

1. 因为udp没有像tcp那样有确认号和和序号字段。tcp发送端会在发送报文会设置一个定时器等待接受方发回确认报文，如果没有收到确认报文就重发原报文。接受方收到报文后会根据序号字段设置确认号返回给发送端。
2. tcp有重传机制，udp没有
3. tcp有滑动窗口控制发送速度，以确保报文发送的速率接受端能接受。udp没有。







# 5CDN

内容分发网络(Content Delivery Network)

CDN部署静态内容指：css,js,图片，图标等，不包括html

CDN是一组分布在不同位置的Web服务器。

CDN 的`工作原理` 就是将源站的资源缓存CDN各个节点上，当请求命中了某个节点的资源缓存时，立即返回客户端，避免每个请求的资源都通过源站获取，避免网络拥塞、缓解源站压力，保证用户访问资源的速度和体验。

## 1CDN解析过程

1. 浏览器器将请求发送至本地DNS服务器。

2. 本地DNS服务器如果没有相应的域名缓存，就会将域名的解析权限交给**CDN专用的DNS服务器**。

3. **CDN专用的DNS服务器**将  **CDN的全局负载均衡设备**发送给浏览器

4. 浏览器发送请求到CDN全局负债均衡设备，CDN的全局负载均衡设备将根据用户的请求URL,选择一台用户所属区域的负载均衡设备，并将请求转发到该设备上

5. 区域负载均衡设备会选择一台最优的缓存服务器节点，获取其ip地址并返回给全局负载均衡设备。（区域负载均衡服务器会根据 缓存服务器离用户的距离，负载情况等一系列情况选择最优的缓存服务器。）

6.   全局负载均衡设备将最优的缓存服务器节点 的ip地址返回给主机浏览器。

7. 用户请求缓存服务器，缓存服务器如果没有用户相要的请求内容，则向上一级缓存服务器请求。直至追溯到网站的源服务器。

   <img src="C:\Users\15439\AppData\Roaming\Typora\typora-user-images\image-20211012211130992.png" alt="image-20211012211130992" style="zoom:67%;" />



## 2CDN的作用

1. 加快访问速度。CDN可以使用户就近获取内容，提高用户访问响应速度和命中率。
2. 当某个服务宕机时，其他服务器可以替代进行服务。







## 3 CDN的应用场景

