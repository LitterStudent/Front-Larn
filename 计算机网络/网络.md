# 0网络分层



<img src="C:\Users\15439\AppData\Roaming\Typora\typora-user-images\image-20211013123124957.png" alt="image-20211013123124957" style="zoom:67%;" />

1. 应用层：为应用程序提供交互服务。如http，DNS.协议等
2. 运输层：为两台主机间的应用进程间提供信息传输。如tcp和udp.
3. 网络层：选择合适的路由和交换节点，确保数据及时传送。如ip协议。
4. 数据链路层：将网络层传下来的IP数据包组装成帧，并再相邻节点的链路上传送帧。
5. 物理层：实现相邻节点间比特流的透明传输，尽可能屏蔽传输介质和通信手段的差异。



1. tcp/ip协议簇：指在使用ip协议时会用到的协议群的统称。

   ## <img src="C:\Users\15439\AppData\Roaming\Typora\typora-user-images\image-20211013123433768.png" alt="image-20211013123433768" style="zoom: 67%;" />

# 1http

## 1.http 的特点

1.基于请求应答模式，一发一送，有来有回。

2.无状态，不保存通信过程中的上下文。每次http请求都是独立不相关的。

3.可靠传输，基于Tcp/ip.

4.灵活可扩展，HTTP允许传输任意类型的数据。传输的类型由Content-Type加以标记。



## 1.5状态码

1xx  信息型状态码

101 SwitchIng Protocols 指示服务器也正在切换的协议。 当http协议转换为webScoket时，如果服务器同意转换，就会发送101

2xx  成功状态码

200 响应成功 数据放在响应体中

204 成功但是无数据

206 表示部分数据。用于http的分块下载。会带上Content-Range字段。



3xx  重定向状态码

301 代表永久重定向，表示资源分配了新的URL.

302 代表临时重定向，表示资源临时被分配了新的 URL。

当网站从http升级成https时，以前的站点都不用了，应当返回301. 这个时候浏览器默认会做缓存优化，在第二次访问的时候自动访问重定向的那个地址。

如果只是暂时不可用，那么直接返回`302`即可，和`301`不同的是，浏览器并不会做缓存优化。



304 协商缓存命中。



4xx  请求报文错误状态码

400 Bad Request 

403  服务器禁止访问

404 Not Found

405 请求的方法不被允许

406 资源无法满足客户端的条件

408 服务器等待太长时间

409 多个请求发生冲突

413 请求的数据太大



5xx  服务端错误状态码

500  服务器错误

501 客户端请求的功能还不支持

**502 Bad Gateway**: 网关错误

503：服务器超载



## 1.6 get 和 post 的区别

1. get会被浏览器缓存，post不会。
2. get使用url传参，不能使用敏感信息，而且传递参数有限。而post是在请求体中传参。较为适合传输敏感信息。
3. 



## 2.http的缺点

 1.无状态：在长连接场景中需要保存上下文，这个时候无状态就是http的缺点。

 2.队头阻塞问题：http长连接时共用一个tcp连接。服务端同时只能处理一个请求，在一个请求消耗过长时间的情况下，请求队列的其他请求就会被阻塞过久。这就是队列阻塞。

3.使用明文传输。把http报文信息暴露给了外界。

## 3如何解决对头阻塞问题：

1.并发连接，浏览器允许对同一个域名发起多个长连接，这就相当于增加了请求队列。

 2.域名分片。将一个域名的子域名都指向同一台主机。

## 4URI和UrL的区别

URI 在于I(Identifier)是统一资源标示符，可以唯一标识一个资源。

URL在于Locater，一般来说（URL）统一资源定位符，可以提供找到该资源的路径，比如http://www.zhihu.com/question/21950864，但URL又是URI，因为它可以标识一个资源，所以URL又是URI的子集。



## 5http 报文格式：

请求行|响应行 + 头部（通用头部，请求球部，响应头部）+实体

### Accept字段： 

 1.Accept:表示接受端想接收的特定类型的数据 

   Content-type:表示发送端发送数据的类型

 2.Accept-Ecoding:表示接收方接收什么样的压缩方式

   Content-Ecoding:表示发送方采用什么压缩方式

3 Accept-Language: 什么语言

  Content-Language

4 Accept-charset: 字符集

   Content-type

  

### 报文长度相关字段：

1. Content-Length ：定长报文

2. Transfer-Ecoding:chunked : 基于长连接持续发送动态内容



### 针对传输大文件，http采用范围请求。 

服务端：

 Accept-Ranges:bytes  :服务器端支持范围请求 

 Content-Range: 0-9/100 服务端返回0-9，总资源大小为100

  Content-Type: multipart/byteranges; boundary=00000010101

 服务端返回的 boundary用于在报文的响应体中做不同请求范围的分隔符



 请求端：

  Range: bytes=0-9  客户端请求0-9范围数据 

  Range: bytes=0-9, 30-39  客户端请求0-9 30-39范围的数据



总之Accept-Ranges和Content-Range为服务端返回的字段。

Range为客户端请求的数据范围。



### http中的表单处理

content-type 取以下的值。

1. application/x-www-form-urlencoded 

​     会将表单数据进行 url编码 以&为分隔符分隔不同数据

​     // 转换过程: {a: 1, b: 2} -> a=1&b=2 -> 如下(最终形   式)"a%3D1%26b%3D2"

  2.multipart/form-data

   请求头的content会带boundary指定表单分割数据用到分割符。不会进行编码。

   上传图片或者文件一般都用这个字段，因为不需要URL编码。



## 6.cookie

cookie:

   cookie是浏览器的4k大小的文本文件。内部以键值对的形式存储。向同一域名发送http请求会携带相同的cookie,服务端拿到cookie进行解析就可以得到客户端的状态。服务的可以通过set-Cookie字段将设置信息写入到客户端的cookie中。

   cookie的属性有：

   1.与生命周期有关：Expires:过期时间 Max-Age时间间隔

   2.与作用域有关：domain和path.

   3.与安全有关：Secure：只能用https传输 

   httpOnly：只能通过http协议传输，js不能访问





## 7.http代理

http请求的中间人，客户端发起请求到代理，代理再发送请求到目标网站主机。实现中转。代理即是客户端也是服务端。

代理可以实现负债均衡，通过代理服务器的算法来指定要发送到网站的哪一台服务器下。





## 8.跨域

由于浏览器的同源策略，(`scheme(协议)`、`host(主机)`和`port(端口)`都相同则为`同源`)非同源站点有这样一些限制:

- 不能读取和修改对方的 DOM
- 不读访问对方的 Cookie、IndexDB 和 LocalStorage
- 限制 XMLHttpRequest 请求。(后面的话题着重围绕这个)



### 跨域的解决方案

1. CORS  (Cross-Origin-Resource-Sharing)跨域资源共享



#### 1对于简单请求（Get,Post,Head）

1. 浏览器发送跨域http请求时，会有一个额外的头部 Origin.包含了发送该请求源站的url.

2. 如果服务器决定响应请求，就会加入 Access-Control-Allow-Origin:<请求源站的url> .
3. 浏览器收到响应后看到有该头部字段就不会丢弃响应。     



#### 2对于复杂请求

 1.浏览器先发送预检请求。

 2.服务的返回相应报文后，有以下字段

Access-Control-Allow-Origin: 表示可以允许请求的源，可以填具体的源名，也可以填`*`表示允许任意源请求。

Access-Control-Allow-Methods: 表示允许的请求方法列表。

Access-Control-Allow-Credentials: 简单请求中已经介绍。

Access-Control-Allow-Headers: 表示允许发送的请求头字段

Access-Control-Max-Age: 预检请求的有效期，在此期间，不用发出另外一条预检请求。

 3.客户端根据预检响应报文判断复杂请求可发送后，然后才发送真正的http请求。



##  9什么是CSRF(Cross-site request forgery) 

跨域请求伪造：是攻击者第三方网站通过欺骗用户的浏览器去访问一个用户的浏览器曾经认证过的网站并运行一些操作。

CSRF 攻击就是攻击者是利用用户的登录态发起恶意请求.



## 1.常见的CRSF攻击



1.get 

 危险网站B在img标签中插入要访问用户认证过的网站A。

2.post

   危险网站B利用一个自动提交的表单，表单的提交地址为用户认证过的网站A.

3.链接型CRSF.

  将链接的的href设置用户认证过的网站A.





## 2CRSF特点 

1. 攻击发起方一般为第三方网站。

   2.冒用用户信息提交操作。



## 3如何防御



1.利用token.





## 10.XSS攻击

### 1简介： 

xss跨站脚本攻击，是一种脚本注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本获取用户的cookie，sessionId,进而危害数据安全。

xss的本质是恶意代码未经过滤，和正常代码一起，浏览器无法分辨哪些是恶意代码导致恶意代码被执行。由于这些代码在用户终端执行，所以能获取到用户信息。恶意代码利用获取到的用户信息可以冒充用户完成相应的操作。



### 2.xss常见的注入方法。



在 HTML 中内嵌的文本中，恶意内容以 script 标签形成注入。

在内联的 JavaScript 中，拼接的数据突破了原本的限制（字符串，变量，方法名等）。

在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签。

在标签的 href、src 等属性中，包含 `javascript:` 等可执行代码。

在 onload、onerror、onclick 等事件中，注入不受控制代码。

在 style 属性和标签中，包含类似 `background-image:url("javascript:...");` 的代码（新版本浏览器已经可以防范）。

在 style 属性和标签中，包含类似 `expression(...)` 的 CSS 表达式代码（新版本浏览器已经可以防范）。





### 3xss的分类



#### 1.存储型xss攻击

​    攻击者通过将恶意代码插入网站主机的数据库中，当用户访问网站时，网站从数据库查询到恶意代码拼接成html返回给浏览器。浏览器解析执行后恶意代码能获取用户的信息。冒充用户发送信息攻击网站。 这种攻击常见于用户有保存数据到网站的数据库，库如商品评论等。



#### 2反射型xss攻击

 攻击者构造出特殊的url，内含恶意代码。用户打开url，网站服务端将恶意代码从url中取出，拼接到html返回给浏览器。浏览器接收到后解析执行同时恶意代码也被执行。



#### 3Dom型xss攻击

攻击者构造出特殊的 URL，其中包含恶意代码。用户打开url,用户浏览器接收到响应后解析执行，前端js取出url中的恶意代码并执行。恶意代码冒充用户访问网站。



### 4xss攻击的预防

#### 1.预防用户输入恶意代码。

输入过滤



#### 2.防范浏览器执行恶意代码。

##### 1.防止html出现注入

 1.改为纯前端渲染，把代码和数据分开

 2.对html做充分的转义。

##### 2防止javaScript执行时，执行恶意代码

 在使用 .innerHTML .outerHTML document.write()要小时不要将恶意代码插入其中。





## 11 http1.1

 http1.1是当前助理的http版本。有以下特点

1.  **默认持久连接**，tcp连接默认不断开,可以被多个请求复用,不用声明 Connection :keep-alive. **长连接时长可以再keep-alive 字段中设置**。
2. 引入管道机制，在同一个tcp连接中可以立即发送tcp请求且不用等待上一次请求的响应。
3. 新增 Etag,if-None-Match等头部字段来控制http缓存失效。
4. 支持断点续传，在请求头的 Range 字段中请求断点范围。 （响应投 Accept-Range:bytes Range-Content:）



## 11.1http缓存

![img](http://static.oschina.net/uploads/space/2015/0119/015353_P04w_568818.png)





## 12 http 2.0

1. 头部压缩。http的头部字段会使用hpack算法进行压缩。
2. 二进制分帧。头信息和数据体都是二进制，并且统称为"帧"：头信息帧和数据帧。
3. 多路复用。复用tcp连接，在一个连接中，客户端和服务端可以同时发送多个请求和响应，且不用按顺序。
4. 服务端推送。服务端可以主动发送报文到客户端。
5. 请求优先级。可以设置数据帧的优先级，让服务端优先处理重要资源。



## 13https

HTTPS = HTTP + SSL/TLS  准确地说，**TLS1.0 = SSL3.1**。

现在主流的版本是 TLS/1.2.  

1. HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议
2. HTTPS标准端口443，HTTP标准端口80。





###   1https 的加密过程

1. 客户端向服务端发起第一次握手，告知服务端客户端所支持的SSL版本，加密算法和密钥长度等信息。
2. 服务器端将自己的公钥发送刚给数字证书认证机构，数字证书认证机构利用自己的私钥对服务器的公钥进行加密，并给服务器颁发证书。（证书包含网站的公钥和数字签名）
3. 服务器端将证书发送给客户端。
4. **客户端利用数字机构的公钥，对私钥加密的数字签名进行解密得到真正的签名。**
5. **客户端在通过签名生成规则生成签名，看看于解密得到的签名是否匹配。如果匹配则认证通过。获取服务器公钥成功**。
6. 客户端用服务器端的公钥加密自己的对称密钥发送给服务端
7. 服务端用密钥解开信息获得客户端的对称密钥。
8. 通信双方可以通过对称密钥来加密信息。



### 2.什么是数字签名证书？

服务端可以向证书颁发机构CA申请证书，以避免中间人攻击（防止证书被篡改）。证书包含三部分内容：tbsCertificate（to be signed certificate）待签名证书内容、证书签名[算法]()和CA给的签名（使用证书签名[算法]()对tbsCertificate进行哈希运算得到哈希值，CA会用它的私钥对此哈希值进行签名，并放在签名部分）。签名是为了验证身份。

![img](https://uploadfiles.nowcoder.com/files/20210921/8683776_1632204112010/https-certificate.png)

服务端把证书传输给浏览器，浏览器从证书里取公钥。证书可以证明该公钥对应该网站。

数字签名的制作过程：

1. CA使用证书签名[算法]()对证书内容（待签名证书内容）进行hash。 
2. 对hash后的值用CA自己的私钥加密，得到数字签名。 

浏览器验证过程：

1. 拿到证书，得到证书内容、证书签名[算法]()和数字签名。 
2. 用CA机构的公钥对数字签名解密（由于是浏览器信任的机构，所以浏览器会保存它的公钥）。 
3. 用证书里的签名[算法]()对证书内容进行hash。 
4. 比较解密后的数字签名和对证书内容hash后的哈希值，相等则表明证书可信。



## 14短轮循，长轮循，webScoket.

1.短轮循

 浏览器每隔一段时间就向服务器发送请求，服务器收到请求后不论服务器端是否有数据更新都直接响应。客户端通过不断的请求来模拟实时获取服务端的数据变化。通过这种方式来实现即时通讯。

缺点：不断请求会浪费资源。

2.长轮循。

浏览器向服务端发送一个请求后，服务端先将请求挂起，并判断数据是否发生变化。当发生变化时返回响应报文。如果一段时间内还没有发生变化，则直接返回报文。客户端在接受到响应后再发送请求。

缺点：连接挂起会浪费资源。

3.webScoket

h5的新协议。全双工通讯协议，允许服务端主动向客户端推送信息。通信双方相互平等，可以互相发送信息。



## 15 反向代理和正向代理

反向代理是代理服务器端，通过接受客户端的请求来分发到服务器端。此时代理服务器对外界表现的像一个服务器。



反向代理是服务端代理，代理服务端。客户端并不知道真正提供服务的的服务端。

正向代理是客户端代理，代理客户端。服务器端不知道发送请求的真正客户端。



# 2DNS

(Domain Name System)域名系统 （一个记录ip地址的超级分布式数据库）

## 1.域名结构

![image-20211012140721759](C:\Users\15439\AppData\Roaming\Typora\typora-user-images\image-20211012140721759.png)

常见的顶级域名有：cn（中国） us(美国)  com  net

![image-20211012141046828](C:\Users\15439\AppData\Roaming\Typora\typora-user-images\image-20211012141046828.png) 



## 2.DNS解析过程： 

1. 浏览器先检查dns缓存是否有该域名的ip地址，有则直接使用，没有的话会再检查操作系统的hosts文件，再没有的话才向本地域名服务器发起请求。
2. 主机向**本地域名服务器**发送请求，请求域名解析，进行递归查询。
3. 本地域名服务器查询自己的DNS缓存，查找成功则返回结果，否则依次向根域名服务器、顶级域名服务器、权限域名服务器依次迭代发起查询请求，直到本地域名服务器获得请求的域名所属的IP地址。
4. 本地域名服务器再将ip地址返回给主机，同时自己也会缓存起来。
5. 主机操作系统会将ip地址和域名缓存到hosts文件，并传给浏览器。浏览器再缓存到dns缓存。

![image-20211012150343154](C:\Users\15439\AppData\Roaming\Typora\typora-user-images\image-20211012150343154.png)

## 3DNS负载均衡

每次使用DNS解析后得到的ip地址不一定相同。这是因为dns会根据该域名下分配的ip地址的服务器主机的负载量等信息来动态地为主机分配合适的服务主机。





# 3TCP

## 1 TCP的特点

1. **Tcp是面向连接的运输层协议。**应用程序在使用tcp协议之前必须先进行tcp连接。传输完数据后必须释放tcp连接。
2. **Tcp提供可靠交付服务**。通过tcp传输的数据是无差错，不重复，不丢失，按序到达。
3. **Tcp提供全双工通信。**Tcp允许发送双方的应用进程同在任何时候都能发送数据。TCP两端都设有发送缓存和接受缓存。tcp的应用进程在把数据传给发送缓存后就可以干自己的事情去了。而Tcp会在合适的时候将发送缓存的内容发送出去。在接收时，将数据放到接收缓存。上层的应用进程在合适的时候读取接收缓存获取数据。
4. **面向字节流。**虽然tcp于应用进程的交互时通过数据块，但是tcp把数据块当成字节流，将数据块放入缓存区中，在合适的时候将缓存区的数据以字节流的形式发送出去或者传递给应用进程。

tcp连接的两端的端点叫做套接字 ，由ip和端口号组成。

套接字（socket） = (ip地址：端口号)



## 2 Tcp的表头

​                 表头只是 20个字节。

<img src="https://docimg10.docs.qq.com/image/1Y2iV29NS2oAjEqbDbe5YQ.png?w=896&h=269" alt="img" style="zoom:80%;" />        

源端口号，目表端口

序列号：报文数据部分的第一个字节的序号

确认号：期待收到对方报文的下一个数据字节的序号

头部长度：4位    确认ACK  同步SYN 紧急URG  推送PSH: 终止FIN 复位RST  

紧急URG：发送应用进程将URG置为1时就是告诉发送方的tcp有紧急数据要处理。于是发送方TCP就将紧急数据插入到本报文段数据的最前面。

推送PSH：发送方TCP置为1时会立即将报文发送出去，**不用等缓存区满了再推送**。

终止FIN：释放TCP连接

复位RST：不懂。



窗口：2字节，报文发送方的窗口大小。 窗口值告诉报文接收方设置发送窗口的大小。



检验和：校验

紧急指针：当URG置为1时，数据报中数据部分紧急数据的长度。



## 3.Tcp的可靠性如何保证：

1. 分块传输：数据被分割成最合适的数据块(UDP的数据报长度不变)

2. 等待确认：发送端发送报文后，通过定时器设置等待接受端发送确认请求，收不到就重发报文。

3. 确认回复：接受端接收报文后，会通过确认号字段发送确认回复

4. 数据校验

5. 乱序重排：接收端能将乱序的数据报重新排序后再发送给应用进程

6. 重复丢弃：接收端会丢弃重复的报文

7. 流量缓冲：两端有固定大小的缓冲区（滑动窗口），防止速度不匹配丢数据

   

## 4.TCP常见面试题

### 1.三次握手过程和为什么要进行三次握手？

 c端： SYN seq=x   -------->                           s端    连接请求请求报文

 c端     <----------  SYN ACK seq=y ack=x+1  s端	连接接受报文

 c端      ACK seq=x+1 ack=y+1      ----->        s端

- 客户端发送SYN，表明要向服务器建立连接。同时带上序列号ISN
- 服务器返回ACK（序号为客户端序列号+1）作为确认。同时发送SYN作为应答（SYN的序列号为服务端唯一的序号）
- 客户端发送ACK确认收到回复（序列号为服务端序列号+1）

原因：

防止A发送的请求连接报文在信道中延迟过久，到TCP连接中断才传递至B端。此时如过是两次握手的话，B端就会向A端发出确认报文并保持该TCP连接，但事实上A端已经关闭，所以不会回复B,造成B的资源浪费。

**确保双方，同时能发数据和收数据**。因为TCP是全双工的。

A发送第一个报文，确保了 A具有发送的能力。

B接收到报文，发送回复报文给A.确保了B具有发送和接受的能力。

A再发送报文给B.确保了A能接受到B的报文。



###  2.四次挥手过程和为什么要四次挥手？

FIN-Wait 1 A   FIN seq=u  ---->                                   B  ESTablshed

FIN-Wait 1 A    <------  ACK  ack=u+1 seq=v               B   CLOSED-WAIT

FIN-Wait 2 A     <------  可能发送剩余信息                   B  CLOSED-WAIT

FIN-Wait 2  A   <-------   ACK+FIN  ack=u+1 seq=w    B  LAST-ACK

TIME-Wait  A      ACK ack=w+1 seq=u+1      ------>    B  CLOSE

- 主动关闭的一方发送FIN，表示要单方面关闭数据的传输
- 服务端收到FIN后，发送一个ACK作为确认（序列号为收到的序列号+1）
- 等服务器数据传输完毕，也发送一个FIN标识，表示关闭这个方向的数据传输
- 客户端回复ACK以确认回复

原因：1因为tcp是全双工的，数据能才两个方向上同时传输。且tcp支持半关闭，即一端停止发送数据但是仍能接受数据。因此每个方向都要单独关闭，且收到关系通知后要确认。

2.因为 服务端在收到客户端的断开连接请求后，可能还存有要发送的数据没发送完，所以才先发送确认收到服务端FIN报文的确认报文后，再继续发送剩余数据。发送完数据之后才发送确认断开连接的FIn报文。



### 3第四次挥手客户端等待2MSL 2个最大报文生存时间 的意义？

为了确保服务端能收到客户端 的确认报文。确保此次连接的tcp报文都彻底消失不会再影响下一次tcp的连接。

第一个msl是为了保证服务端收到确认报文，如果第一个msl内服务端没有收到确认报文就会重发fin报文。然后客户端就会在1msl内收到报文。



## 5滑动窗口协议（流量控制）

1. TCP利用滑动窗口的机制实现流量控制。TCP的会话双方都会维护一个各自的发送窗口和接受窗口。接受窗口大小是取决于应用，系统，硬件等条件。发送窗口取决于对方发送的接受窗口。接受方发送的确认报文通过设置window字段来设置发送方的发送 窗口大小从而影响发送方的发送速率。当接受方设置窗口大小为0时，发送方就不能发送数据。	



## 6拥塞控制



![image-20211013112731729](C:\Users\15439\AppData\Roaming\Typora\typora-user-images\image-20211013112731729.png)

目的：拥塞控制是为了防止过多的数据注入到网络。拥塞控制的几种方法：慢开始，拥塞避免，快重启，快恢复。

1. 滑动窗口cwnd设置为一个最大报文长度MSS的数值。而且在**每收到一个确认报文后就将拥塞窗口增加多一个MSS的值**。即**拥塞窗口cwnd翻倍**。为了防止拥塞窗口过大引起网络拥塞，设置慢开始门限ssthresh。**当拥塞窗口的值到达慢开始门限后ssthresh开始拥塞避免算法。**
2. 拥**塞避免时，每经过一个往返时间RTT，拥塞窗口的值就加1.线性缓慢增长**。
3. 无论是在满开始阶段还是拥塞避免阶段，只要发送方判断出网络中出现拥塞就会将拥塞窗口设为1，慢开始门限设为原来一半，然后执行慢开始算法。这样做的目的为了网络中堆积的报文分组有时间被处理掉。
4. 当个别报文段在网络中丢失后，接受方收到乱序的报文段就会**开启快重传算法，连续发送三个ack报文给发送方**，告知发送方报文丢失。
5. 发送方只要收到三个ack报文就可以判断出发送的报文丢失。然后**将拥塞窗口的值cwnd将为慢开始门限的一半**。然后开始拥塞避免，拥塞窗口线性增长。



# 4UDP

8个字节。有4个字段各占2各字节。 源端口，目的端口。数据报长度。检验和。

## 1TCP和UDP的区别。

1. TCP是面向连接的，UDP是无连接，UDP发送数据前不需要建立连接。
2. TCP面向字节流，把数据看成无结构的字节流。UDP是面向报文的。应用层交付的报文不论长短，UDP都只添加一个首部然后交付给IP层。
3. UDP没有拥塞控制，当网络阻塞时会也不会采取相应措施。
4. tcp首部至少20各字节，udp只有8各字节



## 2为什么说UDP没有TCP可靠？

1. 因为udp没有像tcp那样有确认号和和序号字段。tcp发送端会在发送报文会设置一个定时器等待接受方发回确认报文，如果没有收到确认报文就重发原报文。接受方收到报文后会根据序号字段设置确认号返回给发送端。
2. tcp有重传机制，udp没有
3. tcp有滑动窗口控制发送速度，以确保报文发送的速率接受端能接受。udp没有。







# 5CDN

内容分发网络(Content Delivery Network)

CDN部署静态内容指：css,js,图片，图标等，不包括html

CDN是一组分布在不同位置的Web服务器。



## 1CDN解析过程

1. 浏览器器将请求发送至本地DNS服务器。

2. 本地DNS服务器如果没有相应的域名缓存，就会将域名的解析权限交给**CDN专用的DNS服务器**。

3. **CDN专用的DNS服务器**将  **CDN的全局负载均衡设备**发送给浏览器

4. 浏览器发送请求到CDN去负债均衡设备，CDN的全局负载均衡设备将根据用户的请求URL,选择一台用户所属区域的负载均衡设备，并将请求转发到该设备上

5. 区域负载均衡设备会选择一台最优的缓存服务器节点，获取其ip地址并返回给全局负载均衡设备。（区域负载均衡服务器会根据 缓存服务器离用户的距离，负载情况等一系列情况选择最优的缓存服务器。）

6.   全局负载均衡设备将最优的缓存服务器节点 的ip地址返回给主机浏览器。

7. 用户请求缓存服务器，缓存服务器如果没有用户相要的请求内容，则向上一级缓存服务器请求。直至追溯到网站的源服务器。

   <img src="C:\Users\15439\AppData\Roaming\Typora\typora-user-images\image-20211012211130992.png" alt="image-20211012211130992" style="zoom:67%;" />



## 2CDN的作用

1. 加快访问速度。CDN可以使用户就近获取内容，提高用户访问响应速度和命中率。
2. 当某个服务宕机时，其他服务器可以替代进行服务。







## 3 CDN的应用场景

