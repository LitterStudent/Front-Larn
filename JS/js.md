## 1promise

js解决异步任务的一种方案。将执行异步请求的代码和处理结果的代码清晰的分离了。可以将要异步请求的执行代码放在 new promise((resolve,rejected)=>{ })构造函数内，将处理异步请求结果的代码放在promise.then内。

将异步回调的控制权转移到了promise的手中而不是像封装完ajax第三方库的手中。

promise可以处理将以往的异步执行的回调地狱转换成了可以通过.then来链式执行的代码。可维护性以及可阅读性都得到了增强。



.then() 内的执行函数如果最后返回的不是promsie,就会被Promise.resolve。 

.then 和 .catch 希望传入的是函数，传入其他的会发生透传。

.finally()内的执行函数不会接受任何参数。它用于在最后执行特定操作。

执行完后返回的promise还是上次传入的promise,即使返回promsie也不会替换上次传入的promise.







## 2 async 和 await

async 和 await 能进一步改善promise的链式调用，用**同步的方式，执行异步操作**。

一个函数如果加上async ,那么该函数就会返回一个promise.async函数会将返回值使用Promise.resolve()包装成promise.

await 等待一个promise。await后面的语句就像.then里的语句一样，得等await 等待的Promise状态确定后才会继续执行下去。

如果async函数中某处返回了reject的promise,则后面的代码不会执行。

如果想是错误的地方能被捕获不影响后续代码的执行可以使用 try 和catch捕获错误，或者在await的promise的后面增加一个.catch.







## 3 var let const 

使用 var声明的变量会提升到作用域的首部。被提升的是变量声明部分。

而使用let和const声明的变量则不会被提升。所以let 和const 声明的变量不能提前使用，有暂时性死区的说法。

var在全局作用域中声明的变量会被挂载到全局对象window上，而let和const不会。

var 在函数中使用会声明函数作用域变量，函数外访问不到。而let和const还可以声明块级作用域变量。块级外访问不到。





## 4函数提升和变量提升

使用var声明的变量会被提升，但是被提升的只是变量声明的那部分。

而函数声明也会提升，提升的是整个函数。所以可以在声明整个函数之前直接调用这个函数。





## 5继承

ES5的继承有很多种

1. 原型链继承。通过将父类的实例赋予子类构造函数的原型。缺点：子类实例都共享同一父类实例。
2. 道用构造函数继承。通过在子类的构造函数中调用父类的构造函数来实现对父类实例属性的继承。缺点：无法获取父类的原型。
3. 组合继承，即在子类中调用父类的构造函数也将子类的构造函数的原型指向父类实例。缺点：子类实例的属性会和子类的原型上的属性有重合。
4. 寄生组合继承。通过在子类的构造函数中调用父类的构造函数，同时也将子类的原型的原型指向父类，实现对父类原型的继承。



ES6的继承是通过 Class  Extends 语法糖实现的，本质上还是原型链实现的继承。（大概吧）

class 中的 constructor（类构造函数） 就是ES5中的构造函数。虽然使用  instanceof 去判断时为false .但是在使用 类创建实例时可以直接将constructor（类构造函数）当做构造函数。可以通过在constructor 内声明 类实例的属性。

在class 内 声明的普通方法 ，都会添加到 该类的原型上。

使用static作为前缀的声明的方法会被当做静态方法。

ES6通过 extends字段 声明继承父类 和在类构造函数 constructor中使用 super调用父类的构造函数，完成对this的塑型从而实现继承。内部实现原理还是 es5的寄生组合继承。





## 6 new 构造函数 的过程

生成一个空对象，空对象的隐式指针指向构造函数的原型。执行构造函数并且将构造函数的this指向 新生成的空对象。执行完构造函数，函数内的属性添加到了空对象上。最后 如果构造函数的执行结果没有返回一个对象，那就直接返回之前生成的对象。否则就返回构造函数返回的对象。







## 7事件循环

事件循环 Event Loop是浏览器为解决单线程执行js代码而不引起阻塞的机制。

 先执行script脚本，执行过程中遇到微任务加入微任务队列，遇到宏任务加入宏任务队列。当script脚本执行完也就是js执行栈为空的时候，就会去清空微任务队列。当微任务队列执行，再取出宏任务队列的第一个任务执行。直至两个队列的所有任务都执行完。

宏任务：<script> setTimeout setInerval  requestAnimationFrame ：希望在下一次浏览器重绘之前执行动画 setImmediate(node)

微任务： promise.then all  race 

<img src="C:\Users\15439\AppData\Roaming\Typora\typora-user-images\image-20211016193053562.png" alt="image-20211016193053562" style="zoom:50%;" />



## 8  this的指向

this 就是当可执行代码的调用者。

this的指向是函数被调用的时候决定的。



this一般有几种调用场景

var obj = {a: 1, b: function(){console.log(this);}}

\0. 在全局中，不论是否严格模式，this都指向全局对象。

1、作为对象调用时，指向该对象 obj.b(); // 指向obj

2、作为函数调用, var b = obj.b; b(); // 指向全局window，严格模式下为undefined

3、作为构造函数调用 var b = new Fun(); // this指向当前实例对象

4、作为call与apply调用 obj.b.apply(object, []); // this指向当前的object

\5. 在Dom中事件处理函数中，this指向触发事件的元素 e.currentTarget

6.箭头函数本身没有this,是通过父级上下文获取的this。如果在对象中定义箭头函数，通过对象obj.a，来访问箭头函数时，它的this指向全局上下文。如果时在函构造中定义箭头函数，它的this指向实例的this.

在标准函数和箭头函数中有不同的指向。

在标准函数中，this 引用的是把函数当成方法调用的上下文对象







## 9箭头函数

1.在箭头函数中，没有this. 它的this通过外层上下文获取到的。箭头函数的this取决包裹箭头函数的第一个普通函数的this.

2.箭头函数没有自己的 arguments

3.箭头函数不能作构造函数，使用new会出错。

4.箭头函数没有原型。prototype.

5.let a = (a,b)=>{return a+b} 等于 let a = (a,b)=>a+b 没有{ }不用写return



## 10 函数

1. 普通函数（非箭头函数）都有 prototype（原型）,length(形参个数)
2. 在严格模式下，直接调用函数，函数内的this不会指向windows。二是undeined.



### 1.执行上下文和作用域

作用域是指上下文中定义变量的区域。作用域规定了上下文如何查找变量。

javaScript是词法作用域，即静态作用域。函数的作用域在函数定义时就决定了。



#### 1执行上下文

当**执行一个函数**的时候，就会创建一个**执行上下文**，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。

对于每个执行上下文，都有三个重要属性：

- 变量对象(Variable object，VO)

**变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明**。因为不同执行上下文下的变量对象稍有不同，所以我们来聊聊全局上下文下的变量对象和函数上下文下的变量对象

- 作用域链(Scope chain)

一条变量对象的链条。包含了当前的变量对象以及父级上下文的变量对象，直到全局对象。

当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链

- this

  当前执行上下文的调用者。



var 声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前。这个现象叫作“提升”.



2.**函数声明和函数表达式**

函数声明会提升，且比变量提升优先级高。

```
//函数声明语句写法function test(){}; test();  
//函数表达式写法var test = function(){}; test();
```



## 11对象(Object)

### 1.常见api

Object.keys(obj):返回对象的key的数组

Object.values(obj):返回对象的value的数组

Object.entires(obj):返回二维的数组

Object.assigin(traget,source1,source2):将source1和source2合并到target上

 Object.defineProperty(obj,{value: })：修改属性的默认特性，使用的方法



### 2.原型

 原型就一个为其他对象提供共享属性访问的对象。在创建对象时每个对象都有一个隐式属性指向它的原型或者null.

原型也是对象，所以原型也有自己的原型。这样就构成了原型链。



### 3原型链

对象实例在访问属性时就是在攀升原型链。当前对象是原型链的第一个元素，当属性在这个对象找不到时，就回去访问它的原型，一直攀升原型链直至找到。









































